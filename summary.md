# Введение

Оконные функции помогают делать аналитические отчеты без участия экселя. Опишем основные возможности на примере таблицы:

```
┌────┬──────────┬────────┬────────────┬────────┐
│ id │   name   │  city  │ department │ salary │
├────┼──────────┼────────┼────────────┼────────┤
│ 11 │ Дарья    │ Самара │ hr         │ 70     │
│ 12 │ Борис    │ Самара │ hr         │ 78     │
│ 21 │ Елена    │ Самара │ it         │ 84     │
│ 22 │ Ксения   │ Москва │ it         │ 90     │
│ 23 │ Леонид   │ Самара │ it         │ 104    │
│ 24 │ Марина   │ Москва │ it         │ 104    │
│ 25 │ Иван     │ Москва │ it         │ 120    │
│ 31 │ Вероника │ Москва │ sales      │ 96     │
│ 32 │ Григорий │ Самара │ sales      │ 96     │
│ 33 │ Анна     │ Москва │ sales      │ 100    │
└────┴──────────┴────────┴────────────┴────────┘
```

## Ранжирование

### Общий рейтинг зарплат:

![](assets/2023-04-12-11-23-41-image.png)

У некоторых сотрудников одинаковые зарплаты - поэтому они получили один и тот же ранг.

### Рейтинг зарплат по департаментам:

![](assets/2023-04-12-11-24-37-image.png)

### Группы по зарплате:

Разобьем сотрудников на три группы в зависимости от размера зарплаты: высокооплачиваемые, средние, низкооплачиваемые.

![](assets/2023-04-12-11-26-34-image.png)

### Самые "дорогие" коллеги

Найдем самых высокооплачиваемых людей по каждому департаменту:

![](assets/2023-04-12-11-27-17-image.png)

## Сравнение со смещением

Сравнение со смещением - это когда мы смотрим, в чем разница между соседними значениями. Например, сравниваем страны, которые занимают 5 и 6 место в мировом рейтинге ВВП - сильно ли отличаются? А если сравнить 1 и 6 место?

Сюда же попадают задачи, в которых мы сравниваем значение из набора с границами набора. Например, есть 100 лучших теннисисток мира. Мария Саккари занимает в рейтинге 20 место. Как ее показатели соотносятся с Эшли Бартли, которая занимает 1 место? А с Лин Чжоу, которая занимает 100 место?

### Разница по зарплате с предыдущим

Упорядочим сотрудников по возрастанию зарплаты и проверим, велик ли разрыв между соседями:

![](assets/2023-04-12-11-30-18-image.png)

Столбец `diff` показывает, на сколько процентов зарплата сотрудника отличается от предыдущего коллеги.

### Диапазон зарплат в департаменте

Посмотрим, как зарплата сотрудника соотносится с минимальной и максимальной зарплатой в его департаменте:

![](assets/2023-04-12-11-31-52-image.png)

Для каждого сотрудника столбец `low` показывает минимальную зарплату родного департамента, а столбец `high` - максимальную.

## Агрегация

Агрегация - подсчет суммарных или средних показателей. Например, средняя зарплата по каждому региону или количество золотых медалей у каждой страны в зачете Олимпийских игр.

### Сравнение с фондом оплаты труда

У каждого департамента есть фонд оплаты труда - денежная сумма, которая ежемесячно уходит на выплату зарплат сотрудникам. Посмотрим, какой процент от этого фонда составляет зарплата каждого сотрудника:

![](assets/2023-04-12-11-38-04-image.png)

Столбец `fund` показывает фонд оплаты труда отдела, а `perc` - долю зарплаты сотрудника от этого фонда.

### Сравнение со средней зарплатой

Интересно, велик ли разброс зарплат в департаментах. Чтобы узнать это, необходимо посчитать отклонение зарплаты каждого сотрудника от средней по департаменту:

![](assets/2023-04-12-11-39-45-image.png)

## Скользящие агрегаты

Скользящие агрегаты - те же сумма и среднее, только рассчитывают их не по всем элементам набора, а более хитрым способом.

Для примера возьмем таблицу с доходами и расходами одного сотрудника (пусть Марины) за 9 месяцев:

```
┌──────┬───────┬────────┬─────────┐
│ year │ month │ income │ expense │
├──────┼───────┼────────┼─────────┤
│ 2020 │ 1     │ 94     │ 82      │
│ 2020 │ 2     │ 94     │ 75      │
│ 2020 │ 3     │ 94     │ 104     │
│ 2020 │ 4     │ 100    │ 94      │
│ 2020 │ 5     │ 100    │ 99      │
│ 2020 │ 6     │ 100    │ 105     │
│ 2020 │ 7     │ 100    │ 95      │
│ 2020 │ 8     │ 100    │ 110     │
│ 2020 │ 9     │ 104    │ 104     │
└──────┴───────┴────────┴─────────┘
```

### Скользящее среднее по расходам

Судя по данным, доходы у Марины растут: 94К в январе → 104К в сентябре. А вот растут ли расходы? Сходу сложно сказать, месяц на месяц не приходится. Чтобы сгладить эти скачки, используют «скользящее среднее» — для каждого месяца рассчитывают средний расход с учетом предыдущего и следующего месяца. Например:

- скользящее среднее за февраль = (январь + февраль + март) / 3;
- за март = (февраль + март + апрель) / 3;
- за апрель = (март + апрель + май) / 3;
- и так далее.

Скользящее среднее по всем месяцам:

![](assets/2023-04-12-11-45-01-image.png)

Отсюда видно, что расходы растут.

### Прибыль нарастающим итогом

Благодаря скользящему среднему, мы выяснили, что растут и доходы, и расходы. А как они соотносятся друг с другом? Хочется понять, находится ли человек «в плюсе» или «в минусе» с учетом всех заработанных и потраченных денег.

Причем важно понимать не на конец года, а на каждый месяц. Потому что если по итогам года у Марины все ОК, а в июне ушла в минус — это потенциальная проблема (у компаний такую ситуацию называют «кассовым разрывом»).

Поэтому посчитаем доходы и расходы по месяцам нарастающим итогом (кумулятивно):

- кумулятивный доход за январь = январь;
- за февраль = январь + февраль;
- за март = январь + февраль + март;
- за апрель = январь + февраль + март + апрель;
- и так далее.

![](assets/2023-04-12-11-46-11-image.png)

Теперь видно, что дела у Марины идут неплохо. В некоторых месяцах расходы превышают доходы, но благодаря накоплениям кассового разрыва не происходит.

# Окна и функции

## Ранжирование

Составим рейтинг сотрудников по размеру зп:

![](assets/2023-04-12-13-14-47-image.png)

Сотрудники с одинаковой зарплатой получили один и тот же ранг. 

Переход от было к стало:

1. Отсортируем таблицу по убыванию зарплаты

```sql
select null as rank,
       name,
       department,
       salary
from employees
order by salary desc, id;
```

```
┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Анна     │ sales      │ 100    │
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
│      │ Ксения   │ it         │ 90     │
│      │ Елена    │ it         │ 84     │
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

2. Пройдем от первой строки до последней и проставим ранг каждой записи. Начнем с 1 и будем увеличивать на 1 каждый раз, когда значение `salary` меньше, чем у предыдущей записи:

![](assets/2023-04-12-13-21-45-image.png)

Чтобы проставить ранг, достаточно на каждом шаге смотреть только на значение `salary` , выделенные синей рамкой. Назовем эти значения *окном*.

Опишем содержимое окна словами:

- это значения столбца `salary`

- упорядоченные от большего к меньшему

То же самое на SQL выглядит так:

```sql
window w as (order by salary desc)
```

- `window` - ключевое слово, которое показывает, что дальше будет определение окна

- `w` - название окна (может быть любым)

- `(order by salary desc)` - описание окна (значения столбца `salary упорядоченные по убыванию`)

Задача - посчитать ранг по окну `w`. На SQL это записывается как `dense_rank() over w`. 

`dense_rank()` - *оконная функция*, которая считает ранг по указанному *окну*. Логика `dense_rank()` такая же, как была у нас при ручном подсчете - начать с 1 и увеличивать ранг каждый раз, когда очередное значение из окна отличается от предыдущего.

Добавим окно и оконную функцию в исходный запрос:

```sql
select
  dense_rank() over w as rank,
  name, department, salary
from employees
window w as (order by salary desc)
order by rank, id;
```

```
┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ 2    │ Леонид   │ it         │ 104    │
│ 2    │ Марина   │ it         │ 104    │
│ 3    │ Анна     │ sales      │ 100    │
│ 4    │ Вероника │ sales      │ 96     │
│ 4    │ Григорий │ sales      │ 96     │
│ 5    │ Ксения   │ it         │ 90     │
│ 6    │ Елена    │ it         │ 84     │
│ 7    │ Борис    │ hr         │ 78     │
│ 8    │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

Вот как движок выполняет такой запрос:

1. Берет таблицу, указанную в `from`

2. Выбирает из нее все записи

3. Для каждой записи рассчитывает значение `dense_rank()` с помощью окна `w`

4. Сортирует результат как указано в `order by`

Конструкция `window` сама по себе ничего не делает с результатами запроса. Она только определяет окно, которое можно использовать в запросе. Если убрать вызов `dense_rank()`, запрос отработает, как будто нет никаких окон. Окно начинает работать только тогда, когда в `select` появляется оконная функция, которая его использует.

**В некоторых СУБД (Oracle и MS SQL Server) не поддерживается конструкция `window`, в них "окно" указывается внутри `over`.**

### Сортировка окна и сортировка результатов

Если из запроса:

```sql
select dense_rank() over w as rank,
       name,
       department,
       salary
from employees
    window w as (order by salary desc)
order by rank, id;
```

убрать `order by`, но оставить в окне:

```sql
select dense_rank() over w as rank,
       name,
       department,
       salary
from employees
    window w as (order by salary desc);
```

то ничего не изменится. Но убирать его просто так нельзя, потому что `order by` в окне задает сортировку окна, а `order by` в запросе - сортировку результатов уже после того, как отработало и окно, и все прочие результаты запроса (`join, where, group by`). 

Допустим, мы хотим проставить ранг по убыванию зарплаты, а отсортировать - наоборот, по возрастанию:

```sql
select dense_rank() over w as rank,
       name,
       department,
       salary
from employees
    window w as (order by salary desc)
order by salary asc;
```

```
┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 8    │ Дарья    │ hr         │ 70     │
│ 7    │ Борис    │ hr         │ 78     │
│ 6    │ Елена    │ it         │ 84     │
│ 5    │ Ксения   │ it         │ 90     │
│ 4    │ Вероника │ sales      │ 96     │
│ 4    │ Григорий │ sales      │ 96     │
│ 3    │ Анна     │ sales      │ 100    │
│ 2    │ Леонид   │ it         │ 104    │
│ 2    │ Марина   │ it         │ 104    │
│ 1    │ Иван     │ it         │ 120    │
└──────┴──────────┴────────────┴────────┘
```

Видно, что ранг проставился по сортировке окна (`salary desc`), а результат упорядочен по сортировке основного запроса (`salary asc`).

Если вообще не указать `order by` запроса — порядок записей будет не определен.

### Однозначность сортировки

В запросе было указано `order by rank, id`, но зачем нужен `id`? Он нужен для того, чтобы знать, как сортировать сотрудников с одинаковым рангом. Без `id` порядок записей не определен, и СУБД может расположить их в любом порядке. А с `id` все однозначно - внутри одного ранга порядок будет по `id`.

### Несколько окон

Что делать, если необходимо использовать несколько окон в запросе? Можно перечислить их через запятую в разделе `window`:

```sql
select ...
from ...
where ...
window
  w1 as (...),
  w2 as (...),
  w3 as (...);
```

Пример:

Отранжируем сотрудников по зарплате в прямом и обратом порядке:

```sql
select dense_rank() over w1 as r_asc,
       dense_rank() over w2 as r_desc,
       name,
       salary
from employees
    window
        w1 as (order by salary asc),
        w2 as (order by salary desc)
order by salary, id;ary, id;
```

```
┌───────┬────────┬──────────┬────────┐
│ r_asc │ r_desc │   name   │ salary │
├───────┼────────┼──────────┼────────┤
│ 1     │ 8      │ Дарья    │ 70     │
│ 2     │ 7      │ Борис    │ 78     │
│ 3     │ 6      │ Елена    │ 84     │
│ 4     │ 5      │ Ксения   │ 90     │
│ 5     │ 4      │ Вероника │ 96     │
│ 5     │ 4      │ Григорий │ 96     │
│ 6     │ 3      │ Анна     │ 100    │
│ 7     │ 2      │ Леонид   │ 104    │
│ 7     │ 2      │ Марина   │ 104    │
│ 8     │ 1      │ Иван     │ 120    │
└───────┴────────┴──────────┴────────┘
```

### Рейтинг зарплат по департаментам

Составим рейтинг сотрудников по размеру заработной платы независимо по каждому департаменту:

![](assets/2023-04-12-13-57-40-image.png)

Переход от было к стало:

1. Сортируем таблицу по департаментам, а внутри департамента - по убыванию зарплаты

```sql
select null as rank,
       name,
       department,
       salary
from employees
order by department, salary desc, id;
```

```
┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Ксения   │ it         │ 90     │
│      │ Елена    │ it         │ 84     │
│      │ Анна     │ sales      │ 100    │
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
└──────┴──────────┴────────────┴────────┘
```

Теперь пройдем от первой строчки до последней и проставим ранг каждой записи. Начнем с 1 и будем увеличивать ранг каждый раз, когда значение `salary` меньше, чем у предыдущей записи. При переходе от департамента к департаменту будем сбрасывать ранг обратно на 1:

![](assets/2023-04-12-17-24-37-image.png)

Чтобы проставить ранг, достаточно на каждом шаге смотреть только на значения из столбца `salary`, выделенные синей рамкой. Это и есть *окно* в данном случае.

Видно, что окно меняется в зависимости от того, к какому департаменту относится текущая запись. Опишем словами:

1. Окно разбито на несколько независимых секций - по одной на департамент

2. Внутри секции записи упорядочены по убыванию зарплаты

То же самое на SQL:

```sql
window w as(
    portition by department
    order by salary desc
)
```

- `partition by department` указывает на то, что окно разбивается на секции в соответствии с департаментом

- `order by salary desc` задает сортировку внутри секции

Функция расчета ранга остается прежней - `dense_rank()`.

Добавим окно и оконную функцию в исходный запрос:

```sql
select dense_rank() over w as rank,
       name,
       department,
       salary
from employees
    window w as (
        partition by department
        order by salary desc
        )
order by department, rank, id;
```

```
┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Борис    │ hr         │ 78     │
│ 2    │ Дарья    │ hr         │ 70     │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ 2    │ Леонид   │ it         │ 104    │
│ 2    │ Марина   │ it         │ 104    │
│ 3    │ Ксения   │ it         │ 90     │
│ 4    │ Елена    │ it         │ 84     │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Анна     │ sales      │ 100    │
│ 2    │ Вероника │ sales      │ 96     │
│ 2    │ Григорий │ sales      │ 96     │
└──────┴──────────┴────────────┴────────┘
```

Вот как движок рассчитывает ранг для каждой записи:

<img title="" src="assets/rank-department.gif" alt="" data-align="center" width="336">

### Группы по зарплате

Разобьем сотрудников на три группы в зависимости от размера зарплаты:

- Высокооплачиваемые

- средние

- низкооплачиваемые

![](assets/2023-04-12-17-46-09-image.png)

Переход от было к стало:

1. Отсортируем таблицу по убыванию зарплаты

```sql
select null as tile,
       name,
       department,
       salary
from employees
order by salary desc, id;
```

```
┌──────┬──────────┬────────────┬────────┐
│ tile │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Анна     │ sales      │ 100    │
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
│      │ Ксения   │ it         │ 90     │
│      │ Елена    │ it         │ 84     │
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

Всего 10 записей, 3 группы — значит, две группы по 3 записи и одна 4 записи. Например, так:

```
┌──────┬──────────┬────────────┬────────┐
│ tile │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Анна     │ sales      │ 100    │
├──────┼──────────┼────────────┼────────┤
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
│      │ Ксения   │ it         │ 90     │
├──────┼──────────┼────────────┼────────┤
│      │ Елена    │ it         │ 84     │
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

Чтобы провести границы между группами, придется анализировать все зарплаты, отсортированные по убиванию. Поэтому окно будет таким:

```sql
window w as (order by salary desc)
```

А функция потребуется другая - `ntile(n)`, где `n` - количество групп. В нашем случае:

```sql
select ntile(3) over w as tile,
       name,
       department,
       salary
from employees
    window w as (order by salary desc)
order by
    salary desc,
    id;
```

```
┌──────┬──────────┬────────────┬────────┐
│ tile │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ 1    │ Леонид   │ it         │ 104    │
│ 1    │ Марина   │ it         │ 104    │
│ 1    │ Анна     │ sales      │ 100    │
├──────┼──────────┼────────────┼────────┤
│ 2    │ Вероника │ sales      │ 96     │
│ 2    │ Григорий │ sales      │ 96     │
│ 2    │ Ксения   │ it         │ 90     │
├──────┼──────────┼────────────┼────────┤
│ 3    │ Елена    │ it         │ 84     │
│ 3    │ Борис    │ hr         │ 78     │
│ 3    │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

`ntile(n)` разбивает все записи на `n` групп и возвращает номер группы для каждой записи. Если общее количество записей (у нас 10) не делится на размер группы (мы указали 3), то в первых **K** групп из **N**, где **N** параметр `ntile()` будет ровно на 1 строку больше, если количество строк не делится на **N** и дает остаток **K**)

`ntile(n)` всегда старается разбить данные так, чтобы группы были одинакового размера. Поэтому записи с одинаковым значением могут попасть в соседние группы:

```sql
select ntile(2) over w as tile,
       name,
       department,
       salary
from employees
    window w as (order by salary desc, id)
order by
    salary desc,
    tile;
```

```
┌──────┬──────────┬────────────┬────────┐
│ tile │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ ...                                   │
│ 1    │ Вероника │ sales      │ 96     │ <--
├──────┼──────────┼────────────┼────────┤
│ 2    │ Григорий │ sales      │ 96     │ <--
│ ...                                   │
│ 2    │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

### Функция ранжирования

Оконные функции ранжирования:

| Функция        | Описание                                                                             |
| -------------- | ------------------------------------------------------------------------------------ |
| `row_number()` | порядковый номер строки в секции окна                                                |
| `dense_rank()` | ранг строки                                                                          |
| `rank()`       | тоже ранг, но с пропусками                                                           |
| `ntile(n)`     | разбивает все строки на `n` групп и возвращает номер группы, в которую попала строка |

`row_number()` нумерует строки в порядке, указанном в `order by`.

`rank()` похож на `dense_rank()` разница в том, что `rank()` может пропускать номера:

![](assets/2023-04-13-09-13-00-image.png)

![](assets/2023-04-13-09-13-14-image.png)

`dense_rank()` назначает Анне третье место, а `rank()` — четвертое, потому что второе-третье уже заняты Леонидом и Мариной. Аналогично с Ксенией после Вероники и Григория.

## Смещение

### Сравнение со смещением

Сравнение со смещением - это когда смотрят на разницу между соседними значениями. Сюда же попадают задачи, в которых мы сравниваем значение из набора с границами набора.

### Разница по зарплате с предыдущим

Упорядочим сотрудников по возрастанию зарплаты и проверим, велик ли разрыв между соседями:

![](assets/2023-04-13-10-48-12-image.png)

Столбец `diff` показывает, на сколько процентов зарплата сотрудника отличается от предыдущего коллеги.

Переход от было к стало:

1. Сортируем таблицу по возрастанию зарплаты

```sql
select name,
       department,
       salary,
       null as prev
from employees
order by
    salary,
    id;
```

```
┌──────────┬────────────┬────────┬──────┐
│   name   │ department │ salary │ prev │
├──────────┼────────────┼────────┼──────┤
│ Дарья    │ hr         │ 70     │      │
│ Борис    │ hr         │ 78     │      │
│ Елена    │ it         │ 84     │      │
│ Ксения   │ it         │ 90     │      │
│ Вероника │ sales      │ 96     │      │
│ Григорий │ sales      │ 96     │      │
│ Анна     │ sales      │ 100    │      │
│ Леонид   │ it         │ 104    │      │
│ Марина   │ it         │ 104    │      │
│ Иван     │ it         │ 120    │      │
└──────────┴────────────┴────────┴──────┘
```

Теперь пройдем от первой строки до последней, на каждом шаге подтягивая зарплату предыдущего сотрудника:

![](assets/c82f6431c821f0b471c8f002b262279e92d08522.gif)

Видно, что в данном случае окно скользит. Но у такого окна сложный синтаксис, поэтому оно рассматривается дальше.

Вместо этого возьмем просто окно - все записи, упорядоченные по возрастанию `salary`.

```sql
window w as (order by salary)
```

А чтобы на каждом шаге подтягивать зарплату предыдущего сотрудника, будем использовать оконную функцию `lag(attribute, n)`. Функция `lag()` возвращает значение из указанного столбца, отстоящее от текущего на указанное количество записей назад.

Добавляем окно и оконную функцию в исходный запрос:

```sql
select id,
       name,
       department,
       salary,
       lag(salary, 1) over w as prev
from employees
    window w as (order by salary, id)
order by
    salary,
    id;
```

```
┌────┬──────────┬────────────┬────────┬──────┐
│ id │   name   │ department │ salary │ prev │
├────┼──────────┼────────────┼────────┼──────┤
│ 11 │ Дарья    │ hr         │ 70     │      │
│ 12 │ Борис    │ hr         │ 78     │ 70   │
│ 21 │ Елена    │ it         │ 84     │ 78   │
│ 22 │ Ксения   │ it         │ 90     │ 84   │
│ 31 │ Вероника │ sales      │ 96     │ 90   │
│ 32 │ Григорий │ sales      │ 96     │ 96   │
│ 33 │ Анна     │ sales      │ 100    │ 96   │
│ 23 │ Леонид   │ it         │ 104    │ 100  │
│ 24 │ Марина   │ it         │ 104    │ 104  │
│ 25 │ Иван     │ it         │ 120    │ 104  │
└────┴──────────┴────────────┴────────┴──────┘
```

Теперь остается посчитать разницу между `prev` и `salary` в процентах:

```sql
with emp as (select id,
                    name,
                    department,
                    salary,
                    lag(salary, 1) over w as prev
             from employees
                 window w as (order by salary, id))
select name,
       department,
       salary,
       round((salary - prev) * 100.0 / prev) as diff
from emp
order by
    salary,
    id;salary, id;
```

```
┌──────────┬────────────┬────────┬──────┐
│   name   │ department │ salary │ diff │
├──────────┼────────────┼────────┼──────┤
│ Дарья    │ hr         │ 70     │      │
│ Борис    │ hr         │ 78     │ 11.0 │
│ Елена    │ it         │ 84     │ 8.0  │
│ Ксения   │ it         │ 90     │ 7.0  │
│ Вероника │ sales      │ 96     │ 7.0  │
│ Григорий │ sales      │ 96     │ 0.0  │
│ Анна     │ sales      │ 100    │ 4.0  │
│ Леонид   │ it         │ 104    │ 4.0  │
│ Марина   │ it         │ 104    │ 0.0  │
│ Иван     │ it         │ 120    │ 15.0 │
└──────────┴────────────┴────────┴──────┘
```

Можно избавиться от промежуточной таблицы `emp`, подставив вместо `prev` вызов оконной функции:

```sql
select name,
       department,
       salary,
       round(
               (salary - lag(salary, 1) over w) * 100.0 / lag(salary, 1) over w
           ) as diff
from employees
    window w as (order by salary, id)
order by
    salary,
    id;
```

Здесь мы заменили `prev` → `lag(salary, 1) over w`. Конструкцию вида `function_name(...) over window_name` движок заменяет на конкретное значение, которое вернула функция. Так что оконную функцию можно вызывать прямо внутри вычислений, и вы не раз встретите такие запросы в документации и примерах.

### Диапазон зарплат в департаменте

Посмотрим, как зарплата сотрудника соотносится с минимальной и максимальной зарплатой в его департаменте:

![](assets/2023-04-13-11-52-41-image.png)

Для каждого сотрудника столбец `low` показывает минимальную зарплату родного департамента, а столбец `high` — максимальную.

Переход от было к стало:

1. Сортируем таблицу по департаментам, а внутри каждого департамента - по возрастанию зарплаты

```sql
select name,
       department,
       salary,
       null as low,
       null as high
from employees
order by
    department,
    salary,
    id;
```

```
┌──────────┬────────────┬────────┬─────┬──────┐
│   name   │ department │ salary │ low │ high │
├──────────┼────────────┼────────┼─────┼──────┤
│ Дарья    │ hr         │ 70     │     │      │
│ Борис    │ hr         │ 78     │     │      │
│ Елена    │ it         │ 84     │     │      │
│ Ксения   │ it         │ 90     │     │      │
│ Леонид   │ it         │ 104    │     │      │
│ Марина   │ it         │ 104    │     │      │
│ Иван     │ it         │ 120    │     │      │
│ Вероника │ sales      │ 96     │     │      │
│ Григорий │ sales      │ 96     │     │      │
│ Анна     │ sales      │ 100    │     │      │
└──────────┴────────────┴────────┴─────┴──────┘
```

Теперь пройдем от первой строчки до последней, на каждом шаге «подтягивая» наименьшую и наибольшую зарплаты в отделе:

![](assets/f55dc27174248e62b68913d0c5d84d8d787f7c4b.gif)

Окно состоит из трех секций. Секция на каждом шаге охватывает весь департамент сотрудника. Записи упорядочены по возрастанию зарплаты внутри департамента, чтобы минимальная и максимальная зарплаты всегда находились на границах секции:

```sql
window w as (
  partition by department
  order by salary
)
```

`lag()` и `lead()` в данном случае не подойдут, потому что они заглядывают на определенное количество записей назад или вперед. 

Нам же нужны такие параметры:

- `low` - зарплата первого сотрудника, входящего в секцию окна

- `high` - зарплата последнего сотрудника, входящего в секцию окна

Для них можно воспользоваться специальным оконными функциями:

```sql
first_value(salary) over w as low,
last_value(salary) over w as high
```

Добавляем окно и оконную функцию в исходный запрос:

```sql
select name,
       department,
       salary,
       first_value(salary) over w as low,
       last_value(salary) over w  as high
from employees
    window w as (
        partition by department
        order by salary
        )
order by
    department,
    salary,
    id;
```

```
┌──────────┬────────────┬────────┬─────┬──────┐
│   name   │ department │ salary │ low │ high │
├──────────┼────────────┼────────┼─────┼──────┤
│ Дарья    │ hr         │ 70     │ 70  │ 70   │
│ Борис    │ hr         │ 78     │ 70  │ 78   │
├──────────┼────────────┼────────┼─────┼──────┤
│ Елена    │ it         │ 84     │ 84  │ 84   │
│ Ксения   │ it         │ 90     │ 84  │ 90   │
│ Леонид   │ it         │ 104    │ 84  │ 104  │
│ Марина   │ it         │ 104    │ 84  │ 104  │
│ Иван     │ it         │ 120    │ 84  │ 120  │
├──────────┼────────────┼────────┼─────┼──────┤
│ Вероника │ sales      │ 96     │ 96  │ 96   │
│ Григорий │ sales      │ 96     │ 96  │ 96   │
│ Анна     │ sales      │ 100    │ 96  │ 100  │
└──────────┴────────────┴────────┴─────┴──────┘
```

Для `low` все отработало как нужно, а для `high` нет. Ниже разбор почему так.

### Окно, секция, фрейм

До сих пор все было логично:

- есть окно, которое состоит из одной или нескольких секций

- внутри секции записи упорядочены по конкретному столбцу

На предыдущем шаге мы разделили окно на три секции - по департаментам, и упорядочили записи в секциях по зарплате:

```sql
window w as (
  partition by department
  order by salary
)
```

Допустим, движок выполняет запрос, и текущая запись — Леонид из it-отдела. Мы ожидаем, что `first_value()` вернет первую запись it-секции (`salary = 84`), а `last_value()` — последнюю (`salary = 120`):

![](assets/2023-04-13-12-15-39-image.png)

Вместо этого `last_value()` возвращает `salary = 104`:

![](assets/2023-04-13-12-15-55-image.png)

Дело в том, что функции `first_value()` и `last_value()` работают не просто с секцией окна, они работают с **фреймом** внутри секции:

![](assets/2023-04-13-12-17-23-image.png)

Фрейм находится в той же секции, где текущая запись (Леонид):

- начало фрейма = начало секции (Елена)

- конец фрейма = последняя запись со значением `salary`, равным текущей записи (Марина)

Секция фиксирована, фрейм же зависит от текущей записи и постоянно меняется:

**Секция**

![](assets/9bba1ced0af9db95adf2407d17d08850cca7c40e.gif)

**Фрейм**

![](assets/7b31d816e116d4ce6d03bf93047975971b309a0f.gif)

`first_value()` возвращает первую строчку фрейма, а не секции. Но поскольку начало фрейма совпадает с началом секции, функция отрабатывает как мы ожидали.

`last_value()` возвращает последнюю строчку фрейма, а не секции. Именно поэтому в нашем запросе она вернула не максимальную зарплату для каждого отдела, а какую-то ерунду.

Чтобы `last_value()` работала как мы ожидаем, придется «прибить» границы фрейма к границам секции. Тогда для каждой секции фрейм будет в точности совпадать с ней:

![](assets/2023-04-13-12-24-55-image.png)

Подытожим принцип, по которому работают `first_value()` и `last_value()`:

1. Есть *окно*, которое состоит из одной или нескольких *секций* (`partition by department`).
2. Внутри секции записи упорядочены по конкретному столбцу (`order by salary`).
3. У каждой записи в секции свой *фрейм*. По умолчанию начало фрейма совпадает с началом секции, а конец для каждой записи свой.
4. Конец фрейма можно приклеить к концу секции, чтобы фрейм в точности совпадал с секцией.
5. Функция `first_value()` возвращает значение из первой строки фрейма.
6. Функция `last_value()` возвращает значение из последней строки фрейма.

Теперь разберемся, как прибить фрейм к окну — и закончим с запросом по диапазону зарплат в департаментах.

### Диапазон зарплат в департаменте, окончание

Чтобы фрейм в точности совпадал с секцией (департаментом) нужно изменить определение окна так:

```sql
window w as (
  partition by department
  order by salary
  rows between unbounded preceding and unbounded following
)
```

Благодаря конструкции `rows between` фрейм совпадает с секцией. Подробнее эта конструкция рассматривается позже.

Окончательный вид нашего запроса:

```sql
select name,
       department,
       salary,
       first_value(salary) over w as low,
       last_value(salary) over w  as high
from employees
    window w as (
        partition by department
        order by salary
        rows between unbounded preceding and unbounded following
        )
order by
    department,
    salary,
    id;
```

```
┌──────────┬────────────┬────────┬─────┬──────┐
│   name   │ department │ salary │ low │ high │
├──────────┼────────────┼────────┼─────┼──────┤
│ Дарья    │ hr         │ 70     │ 70  │ 78   │
│ Борис    │ hr         │ 78     │ 70  │ 78   │
├──────────┼────────────┼────────┼─────┼──────┤
│ Елена    │ it         │ 84     │ 84  │ 120  │
│ Ксения   │ it         │ 90     │ 84  │ 120  │
│ Леонид   │ it         │ 104    │ 84  │ 120  │
│ Марина   │ it         │ 104    │ 84  │ 120  │
│ Иван     │ it         │ 120    │ 84  │ 120  │
├──────────┼────────────┼────────┼─────┼──────┤
│ Вероника │ sales      │ 96     │ 96  │ 100  │
│ Григорий │ sales      │ 96     │ 96  │ 100  │
│ Анна     │ sales      │ 100    │ 96  │ 100  │
└──────────┴────────────┴────────┴─────┴──────┘
```

### Функции смещения

| Функция               | Описание                                                              |
| --------------------- | --------------------------------------------------------------------- |
| `lag(value, offset)`  | значение value из строки, отстоящей на offset строк назад от текущей  |
| `lead(value, offset)` | значение value из строки, отстоящей на offset строк вперед от текущей |
| `first_value(value)`  | значение value из первой строки фрейма                                |
| `last_value(value)`   | значение value из последней строки фрейма                             |
| `nth_value(value, n)` | значение value из `n`-й строки фрейма                                 |

## Агрегация

Агрегация - подсчет суммарных или средних показателей. Например средняя зарплата по региону.

### Сравнение с фондом оплаты труда

У каждого департамента есть фонд оплаты труда — денежная сумма, которая ежемесячно уходит на выплату зарплат сотрудникам. Посмотрим, какой процент от этого фонда составляет зарплата каждого сотрудника:

![](assets/2023-04-13-13-11-31-image.png)

Столбец `fund` показывает фонд оплаты труда отдела, а `perc` — долю зарплаты сотрудника от этого фонда.

Переход от было к стало:

1. Отсортируем таблицу по департаментам

```sql
select name,
       department,
       salary,
       null as fund,
       null as perc
from employees
order by
    department,
    salary,
    id;
```

```
┌──────────┬────────────┬────────┬──────┬──────┐
│   name   │ department │ salary │ fund │ perc │
├──────────┼────────────┼────────┼──────┼──────┤
│ Дарья    │ hr         │ 70     │      │      │
│ Борис    │ hr         │ 78     │      │      │
│ Елена    │ it         │ 84     │      │      │
│ Ксения   │ it         │ 90     │      │      │
│ Леонид   │ it         │ 104    │      │      │
│ Марина   │ it         │ 104    │      │      │
│ Иван     │ it         │ 120    │      │      │
│ Вероника │ sales      │ 96     │      │      │
│ Григорий │ sales      │ 96     │      │      │
│ Анна     │ sales      │ 100    │      │      │
└──────────┴────────────┴────────┴──────┴──────┘
```

2. Проходим от первой строки до последней и считаем:
- `fund` - сумма зарплат по департаменту в целом (одинакова для всех сотрудников департамента)

- `perc` - доля зарплаты сотрудника от ФОТ

![](assets/dcca825992b8965dad87b277097f1305aaa2632c.gif)

Окно состоит из секций по департаментам. При этом порядок записей в секции неважен: мы считаем сумму значений `salary`, а она не зависит от порядка.

```sql
window w as (
  partition by department
)
```

Для расчета `fund` подойдет обычная функция `sum()` — ее можно использовать поверх окна. А `perc` посчитаем как `salary / fund`:

```sql
select name,
       department,
       salary,
       sum(salary) over w                         as fund,
       round(salary * 100.0 / sum(salary) over w) as perc
from employees
    window w as (partition by department)
order by
    department,
    salary,
    id;
```

```
┌──────────┬────────────┬────────┬──────┬──────┐
│   name   │ department │ salary │ fund │ perc │
├──────────┼────────────┼────────┼──────┼──────┤
│ Дарья    │ hr         │ 70     │ 148  │ 47.0 │
│ Борис    │ hr         │ 78     │ 148  │ 53.0 │
├──────────┼────────────┼────────┼──────┼──────┤
│ Елена    │ it         │ 84     │ 502  │ 17.0 │
│ Ксения   │ it         │ 90     │ 502  │ 18.0 │
│ Леонид   │ it         │ 104    │ 502  │ 21.0 │
│ Марина   │ it         │ 104    │ 502  │ 21.0 │
│ Иван     │ it         │ 120    │ 502  │ 24.0 │
├──────────┼────────────┼────────┼──────┼──────┤
│ Вероника │ sales      │ 96     │ 292  │ 33.0 │
│ Григорий │ sales      │ 96     │ 292  │ 33.0 │
│ Анна     │ sales      │ 100    │ 292  │ 34.0 │
└──────────┴────────────┴────────┴──────┴──────┘
```

Функция `sum()` считает сумму значений по всей секции, которой принадлежит текущая строка.

### Фильтрация и порядок выполнения

Вернемся к запросу, который считал фонд оплаты труда по департаменту:

```sql
select name,
       department,
       salary,
       sum(salary) over w as fund
from employees
    window w as (partition by department)
order by
    department,
    salary,
    id;
```

```
┌──────────┬────────────┬────────┬──────┐
│   name   │ department │ salary │ fund │
├──────────┼────────────┼────────┼──────┤
│ Дарья    │ hr         │ 70     │ 148  │
│ Борис    │ hr         │ 78     │ 148  │
│ Елена    │ it         │ 84     │ 502  │
│ Ксения   │ it         │ 90     │ 502  │
│ Леонид   │ it         │ 104    │ 502  │
│ Марина   │ it         │ 104    │ 502  │
│ Иван     │ it         │ 120    │ 502  │
│ Вероника │ sales      │ 96     │ 292  │
│ Григорий │ sales      │ 96     │ 292  │
│ Анна     │ sales      │ 100    │ 292  │
└──────────┴────────────┴────────┴──────┘
```

Допустим, мы хотим оставить в отчете только самарских сотрудников. Добавим фильтр:

```sql
select name,
       department,
       salary,
       sum(salary) over w as fund
from employees 
where
    city = 'Самара'
    window w as (partition by department)
order by
    department,
    salary,
    id;
```

```
┌──────────┬────────┬──────┐
│   name   │ salary │ fund │
├──────────┼────────┼──────┤
│ Дарья    │ 70     │ 148  │
│ Борис    │ 78     │ 148  │
│ Елена    │ 84     │ 188  │
│ Леонид   │ 104    │ 188  │
│ Григорий │ 96     │ 96   │
└──────────┴────────┴──────┘
```

Фильтр сработал. Вот только значения `fund` отличаются от ожидаемых:

![](assets/2023-04-13-13-44-05-image.png)

Все дело в порядке выполнения операций. Вот в какой последовательности действует движок, когда выполняет запрос:

1. Взять нужные таблицы (`from`) и соединить их при необходимости (`join`).
2. Отфильтровать строки (`where`).
3. Сгруппировать строки (`group by`).
4. Отфильтровать результат группировки (`having`).
5. Взять конкретные столбцы из результата (`select`).
6. **Рассчитать значения оконных функций** (`function() over window`).
7. Отсортировать то, что получилось (`order by`).

Таким образом, окна отрабатывают предпоследним шагом, уже после фильтрации и группировки результатов. Поэтому в нашем запросе `fund` отражает не сумму всех зарплат по департаменту, а сумму только по самарским сотрудникам.

Решение — использовать подзапрос с окном и фильтровать его в основном запросе:

```sql
with emp as (select name,
                    city,
                    salary,
                    sum(salary) over w as fund
             from employees
                 window w as (partition by department)
             order by department, salary, id)
select name, salary, fund
from emp
where city = 'Самара';
```

```
┌──────────┬────────┬──────┐
│   name   │ salary │ fund │
├──────────┼────────┼──────┤
│ Дарья    │ 70     │ 148  │
│ Борис    │ 78     │ 148  │
│ Елена    │ 84     │ 502  │
│ Леонид   │ 104    │ 502  │
│ Григорий │ 96     │ 292  │
└──────────┴────────┴──────┘
```

### Описание окна

До сих пор мы описывали окно в блоке `window` и ссылались на него в выражении `over`:

```sql
select name,
       department,
       salary,
       count(*) over w    as emp_count,
       sum(salary) over w as fund
from employees
    window w as (partition by department)
order by
    department,
    salary,
    id;
```

```
┌──────────┬────────────┬────────┬───────────┬──────┐
│   name   │ department │ salary │ emp_count │ fund │
├──────────┼────────────┼────────┼───────────┼──────┤
│ Дарья    │ hr         │ 70     │ 2         │ 148  │
│ Борис    │ hr         │ 78     │ 2         │ 148  │
│ Елена    │ it         │ 84     │ 5         │ 502  │
│ Ксения   │ it         │ 90     │ 5         │ 502  │
│ Леонид   │ it         │ 104    │ 5         │ 502  │
│ Марина   │ it         │ 104    │ 5         │ 502  │
│ Иван     │ it         │ 120    │ 5         │ 502  │
│ Вероника │ sales      │ 96     │ 3         │ 292  │
│ Григорий │ sales      │ 96     │ 3         │ 292  │
│ Анна     │ sales      │ 100    │ 3         │ 292  │
└──────────┴────────────┴────────┴───────────┴──────┘
```

Это не единственный способ. SQL разрешает вообще не использовать `window` и описывать окно прямо внутри `over`:

```sql
select name,
       department,
       salary,
       count(*) over (partition by department)    as emp_count,
       sum(salary) over (partition by department) as fund
from employees
order by
    department,
    salary,
    id;
```

Вариант с `window` легче читается и окно более явно переиспользуется.

Определение окна также может быть пустым:

```sql
select name,
       department,
       salary,
       count(*) over ()    as emp_count,
       sum(salary) over () as fund
from employees
order by
    department,
    salary,
    id;
```

Такое окно включает все строки, так что `emp_count` покажет общее количество сотрудников, а `fund` — общий фонд оплаты труда по всем записям `employees`.

### Функции агрегации

| Функция                          | Описание                                                                                                 |
| -------------------------------- | -------------------------------------------------------------------------------------------------------- |
| `min(value)`                     | минимальное `value` среди строк, входящих в окно                                                         |
| `max(value)`                     | максимальное `value`                                                                                     |
| `count(value)`                   | количество `value`, не равных `null`                                                                     |
| `avg(value)`                     | среднее значение по всем `value`                                                                         |
| `sum(value)`                     | сумма значений `value`                                                                                   |
| `group_concat(value, separator)` | строка, которая соединяет значения `value` через разделитель `separator` поддерживается в SQLite и MySQL |
| `string_agg(value, separator)`   | аналог `group_concat()` в PostgreSQL и MS SQL                                                            |

## Скользящие агрегаты

Скользящие агрегаты — это те же сумма и среднее, только скользящие (sic!).

### Скользящее среднее по расходам

Рассчитаем скользящее среднее по расходам:

![](assets/2023-04-13-17-41-33-image.png)

Столбец `roll_avg` показывает скользящее среднее по расходам за три месяца (предыдущий, текущий, следующий).

Переход от было к стало:

1. Отсортируем таблицу по месяцам

```sql
select year,
       month,
       expense,
       null as roll_avg
from expenses
order by
    year,
    month;
```

```
┌──────┬───────┬─────────┬──────────┐
│ year │ month │ expense │ roll_avg │
├──────┼───────┼─────────┼──────────┤
│ 2020 │ 1     │ 82      │          │
│ 2020 │ 2     │ 75      │          │
│ 2020 │ 3     │ 104     │          │
│ 2020 │ 4     │ 94      │          │
│ 2020 │ 5     │ 99      │          │
│ 2020 │ 6     │ 105     │          │
│ 2020 │ 7     │ 95      │          │
│ 2020 │ 8     │ 110     │          │
│ 2020 │ 9     │ 104     │          │
└──────┴───────┴─────────┴──────────┘
```

2. Теперь пройдем от первой строчки до последней. На каждом шаге будем считать среднее по предыдущему, текущему и следующему значению из столбца `expense`:

![](assets/de8a45a5c4c854ef9c63f40c3c49b9ef14bcf3c8.gif)

Рамка на каждом шаге сдвигается вниз, скользит — так и получается скользящее среднее. Чтобы описать на SQL, придется вспомнить концепцию фреймов, с которой мы познакомились на уроке о смещении:

1. Окно состоит из одной или нескольких секций (в нашем случае секция одна — все записи `expenses`).

2. Внутри секции записи упорядочены по конкретным столбцам (`order by year, month`).

3. У каждой записи свой фрейм.

Фрейм на каждом шаге охватывает три записи — текущую, предыдущую и следующую. Вот как это записать в SQL:

```sql
window w as (
  order by year, month
  rows between 1 preceding and 1 following
)
```

Вторая строчка - это определение фрейма: «выбрать строки от 1 предыдущей до 1 следующей». 

Для средней по расходам используем `avg()`:

```sql
avg(expense) over w
```

3. Добавляем округление и используем окно в исходном запросе:

```sql
select year,
       month,
       expense,
       round(avg(expense) over w) as roll_avg
from expenses
    window w as (
        order by year, month
        rows between 1 preceding and 1 following
        )
order by
    year,
    month;
```

```
┌──────┬───────┬─────────┬──────────┐
│ year │ month │ expense │ roll_avg │
├──────┼───────┼─────────┼──────────┤
│ 2020 │ 1     │ 82      │ 79.0     │
│ 2020 │ 2     │ 75      │ 87.0     │
│ 2020 │ 3     │ 104     │ 91.0     │
│ 2020 │ 4     │ 94      │ 99.0     │
│ 2020 │ 5     │ 99      │ 99.0     │
│ 2020 │ 6     │ 105     │ 100.0    │
│ 2020 │ 7     │ 95      │ 103.0    │
│ 2020 │ 8     │ 110     │ 103.0    │
│ 2020 │ 9     │ 104     │ 107.0    │
└──────┴───────┴─────────┴──────────┘
```

Скользящее среднее по расходам готово.

### Фрейм

В общем случае определение фрейма выглядит так:

```sql
rows between X preceding and Y following
```

где `X` - количество строк перед текущей, а `Y` - количество строк после текущей.

Если вместо `X` или `Y` указать `unbounded` - это будет значить, что нужно брать фрейм по размеру секции.

Также вместо `X preceding` или `Y following` можно указать `current row` - тогда фрейм будет ограничен текущей записью.

Фрейм никогда не выходит за границы секции, если столкнулся с ней - обрезается.

### Прибыль нарастающим итогом

Благодаря скользящему среднему мы выяснили, что в таблице `expenses` растут и доходы, и расходы. Теперь посчитаем доходы и расходы по месяцам нарастающим итогом (кумулятивно).

![](assets/2023-04-13-18-15-52-image.png)

`t_income` показывает доходы нарастающим итогом, `t_expense` - расходы, а `t_profit` - прибыль

$$
t_{profit} = t_{income} - t_{expense}
$$

1. Отсортируем таблицу по месяцам

```sql
select year,
       month,
       income,
       expense,
       null as t_income,
       null as t_expense,
       null as t_profit
from expenses
order by
    year,
    month;
```

2. Пройдем от первой строчки до последней. На каждом шаге будем считать суммарные показатели от начала таблицы до текущей строки

![](assets/c1241d16fc7961ace7875b55ccedd2ac9c5646eb.gif)

Фрейм такого типа выглядит следующим образом:

```sql
window w as (
    order by year, month
    rows between unbounded preceding and current row
)
```

3. Все вместе:

```sql
select year,
       month,
       income,
       expense,
       sum(income) over w                           as t_income,
       sum(expense) over w                          as t_expense,
       (sum(income) over w) - (sum(expense) over w) as t_profit
from expenses
    window w as (
        order by year, month
        rows between unbounded preceding and current row
        )
order by
    year,
    month;
```

```
┌──────┬───────┬────────┬─────────┬──────────┬───────────┬──────────┐
│ year │ month │ income │ expense │ t_income │ t_expense │ t_profit │
├──────┼───────┼────────┼─────────┼──────────┼───────────┼──────────┤
│ 2020 │ 1     │ 94     │ 82      │ 94       │ 82        │ 12       │
│ 2020 │ 2     │ 94     │ 75      │ 188      │ 157       │ 31       │
│ 2020 │ 3     │ 94     │ 104     │ 282      │ 261       │ 21       │
│ 2020 │ 4     │ 100    │ 94      │ 382      │ 355       │ 27       │
│ 2020 │ 5     │ 100    │ 99      │ 482      │ 454       │ 28       │
│ 2020 │ 6     │ 100    │ 105     │ 582      │ 559       │ 23       │
│ 2020 │ 7     │ 100    │ 95      │ 682      │ 654       │ 28       │
│ 2020 │ 8     │ 100    │ 110     │ 782      │ 764       │ 18       │
│ 2020 │ 9     │ 104    │ 104     │ 886      │ 868       │ 18       │
└──────┴───────┴────────┴─────────┴──────────┴───────────┴──────────┘
```

### Фрейм по умолчанию

Возьмем запрос, который считает расходы нарастающим итогом:

```sql
select year,
       month,
       expense,
       sum(expense) over w as total
from expenses
    window w as (
        order by year, month
        rows between unbounded preceding and current row
        )
order by
    year,
    month;
```

```
┌──────┬───────┬─────────┬───────┐
│ year │ month │ expense │ total │
├──────┼───────┼─────────┼───────┤
│ 2020 │ 1     │ 82      │ 82    │
│ 2020 │ 2     │ 75      │ 157   │
│ 2020 │ 3     │ 104     │ 261   │
│ 2020 │ 4     │ 94      │ 355   │
│ 2020 │ 5     │ 99      │ 454   │
│ 2020 │ 6     │ 105     │ 559   │
│ 2020 │ 7     │ 95      │ 654   │
│ 2020 │ 8     │ 110     │ 764   │
│ 2020 │ 9     │ 104     │ 868   │
└──────┴───────┴─────────┴───────┘
```

Уберем из него определение фрейма:

```sql
select year,
       month,
       expense,
       sum(expense) over w as total
from expenses
    window w as (
        order by year, month
        )
order by
    year,
    month;
```

Ожидаем, что в `total` теперь всегда будет одно и то же число — суммарные расходы за 9 месяцев. А вместо этого видим вот что:

![](assets/2023-04-13-18-37-27-image.png)

Запрос без фрейма все равно посчитал кумулятивные расходы — в точности как запрос с фреймом. Так произошло из-за наличия сортировки в окне. Правило такое:

если в окне есть `order by` и используется функция агрегации и не указано определение фрейма, то используется фрейм по умолчанию.

Фрейм по умолчанию в нашем запросе распространяется от первой записи до текущей. Поэтому результаты совпадают с запросом, где фрейм был указан явно `rows between unbounded preceding and current row`. Лучше всегда указывать фрейм явно, даже если есть `order by` и дефолтный фрейм подходит.

### Функции для скользящих агрегатов

Скользящие агрегаты используют те же самые функции, что и агрегаты обычные:

- `min() / max()`

- `count(), avg(), sum()`

- `group_concat()`

Отличие только в наличии фрейма у скользящих агрегатов.


